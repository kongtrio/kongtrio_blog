[TOC]

# 一、Mysql 逻辑架构

![Mysql架构图](http://assets.processon.com/chart_image/5ee31964f346fb1ae55d6b8c.png?_=1591942325557)

从整体来看，Mysql的整体架构图可以分为6个组件：

## 1、客户端

这里的客户端即我们用于访问Mysql服务的工具，它可以是Mysql命令控制台，或者写在程序中的接口调用，或者一些可视化软件(比如Navicat、phpMyAdmin等等)。

这些客户端都通过Mysql提供的协议和Mysql服务进行通信，即客户端发生命令，然后Mysql服务解析执行后返回结果。

## 2、请求/连接处理器

在Mysql中，位于最上层的服务是用来处理请求和连接的，主要负责连接管理，授权认证，安全等。每一个客户端的连接都对应着Mysql服务端上的一个线程，Mysql服务端会维护一个 线程池，因此当客户端连接释放后，不用销毁线程，再由新的连接进来时，直接从线程池获取一个新的线程即可。

此外，客户端连接Mysql时，一些安全认证也是在此处处理的，比如账号密码是否正确，是否有操作权限等。

我们可以看出，这一层和大多数软件服务类似，采用的比较通用的网络层解决方案。

## 3、Sql 解析器

顾名思义，就是用来解析客户端请求的Sql的，Mysql会根据语义规则解析Sql，最后转成内部自定义的数据结构（解析树），方便后续的优化器和存储引起进行优化和执行。

##  4、缓存器

如果Mysql在接受Select查询时，如果缓存中有同样的查询，就可以直接从缓存中直接捞出结果，不用再经过优化器和存储引擎，提高查询性能。

## 5、优化器 

解析完的数据结构经过优化器处理后，会生成可执行的执行计划。一般一条查询都有多种执行计划，优化器的任务就是从找出最优的那条执行计划，在这期间，优化器可能需要调用存储引擎的API去查询一些表的统计信息，以及查询执行某个操作的开销。这样，最终得出最优的执行计划。

值得一提的是，在优化器这一层，它并不关心底层使用的存储引擎是啥，只需要调用抽象出来的存储引擎的相关API即可。

## 6、存储引擎

存储引擎是Mysql服务中最重要的一层，负责数据的存储和读取。Mysql抽象出了一系列存储引擎的接口，这样，上层就可以不关心存储引擎的具体实现，直接调用接口即可。

目前社区用的最多的存储引擎就MyIsam和InnoDB，我们在下一章节重点介绍。

> 存储引擎的设置粒度是表级别，即一个数据库下的不同表可以使用不同的存储引擎

# 二、Mysql 存储引擎介绍 

## 1、MyIsam 存储引擎

在Mysql 5.1及之前的版本中，默认的存储引擎就是MyIsam。MyIsam虽然提供了大量的特性，但不支持事务和行级锁，而且还有一个致命的缺陷，就是崩溃后无法安全的恢复（需要执行命令手动去修复损坏的表）。

### 1.1 存储

MyIsam将表存储在两个文件中：数据文件和索引文件，分别以.MYD和.MYI结尾，文件名即表名。比如有个test的表，那么库的目录下会有3个文件：

```shell
test.frm  - 描述test表的文件
test.MYD  - test表的数据文件
test.MYI  - test表的所有文件
```

### 1.2 一些特性

**加锁**：MyIsam 的加锁是针对整张表进行加锁的，读取的时候加共享锁，写入的时候加排他锁。但是在读取查询的同时，也可以往表中插入新的数据（这被称为并发插入）。

**修复**：可以通过 check table tableName来检查表的错误，如果有错误可以执行 repair table tableName来修复表（这个过程会很慢）。如果mysql服务没开启，也可以通过myisamchk来进行检查和修复操作。

**索引特性**：即使对于BLOB和TEXT类型的字段，也可以基于前500个字符创建索引。同时支持全文索引。

**延迟更新索引键**：创建MyIsam表时如果指定DELAY_KEY_WRITE，那么每次执行修改时，并不会马上将修改写到磁盘，而是先写到缓存，之后再刷到磁盘。这样虽然可以极大的提升写的性能，但是如果遇到服务器崩溃或者Mysql进程崩溃，就可能导致索引损坏，需要执行修复操作。

**压缩**：MyIsam可以使用myisampack对表进行压缩，减少表的存储空间（代价是这张表后续就只能读取不能更新了）。

## 2、InnoDb 存储引擎

在5.1之后，InnoDb就成为了Mysql的默认事务型引擎，也是最重要，使用最广泛的存储引擎。它被设计用来处理大量的短期事务，短期事务大部分是正常提交的，很少会回滚。另外，InnoDb的性能和自动崩溃恢复特性，使它在非事务型的需求中也很流行。**除非有特别的原因需要使用其他的存储引擎，否则应该优先考虑使用InnoDb引擎。**

### 2.1 存储

InnoDb 的数据存储在表空间中，这个表空间在物理上的表现形式就是一个以.ibd结尾的文件。它可以理解成是由InnoDB管理的黑盒子，可以由多个数据文件组成。在Mysql 4.1之后，可以将每张表的数据和索引文件存放在单独的文件中。**也就是说，一个表空间可以存储多张表的数据，也可以只存储一张表的数据。**假设有个test表，数据文件可能如下：

```shell
test.frm  - 描述test表的文件
test.idb  - 表空间文件
```

### 2.2 一些特性

**加锁**：InnoDb 支持行级锁、间隙锁。

**索引特性**：InnoDb 表是基于聚簇索引建立的，也就是索引的叶子节点会存储行的数据，所以InnoDb中通过主键查询数据性能会非常好（只要一次查询，而MyIsam需要两次）。

**多版本并发控制**：InnoDb 实现了MVCC(多版本控制)，它可以在很多情况下避免加锁操作，因此开销更低。

## 3、MyIsam 和 InnoDb 对比 

![对比](http://assets.processon.com/chart_image/5ee35e566376891e81c7ba9b.png?_=1592188625760)

## 4、其他的一些存储引擎  

除了InnoDb和MyIsam外，Mysql还有一些其他的存储引擎，有兴趣的可以稍微了解下（下面只介绍一部分存储引擎）：

1、**Archive引擎**：只支持Select和Insert操作，Archive会缓存所有的写并使用zlib对插入的行进行压缩，因此写性能会更高。但是每次查询都需要全表扫描，因此比较适合日志和数据类采集应用，这类应用做分析时通常需要全表扫描。

2、**CSV引擎**：CSV文件就是其存储文件，不支持索引。

3、**Memory 引擎**：正如其名,Memory 存储引擎中的数据都存放在内存中,数据库重启或发生崩溃,表中的数据都将消失。它非常适合于存储 OLTP 数据库应用中临时数据的临时表,也可以作为 OLAP 数据库应用中数据仓库的维度表。Memory 存储引擎默认使用哈希 索引,而不是通常熟悉的 B+ 树索引。



# 参考资料

《高性能Mysql（第三版）》

[『浅入浅出』MySQL 和 InnoDB](https://draveness.me/mysql-innodb/)