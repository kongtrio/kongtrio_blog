[TOC]

## 一、背景介绍  

### 1. 工作流调度系统  

在任务数不多、任务间关系还不复杂时，我们依靠crontab或者quarz框架就可以搭建起一个简单的任务调度系统。这些任务只是很简单的依赖于时间执行，要解决任务依赖的需求，只能在任务中通过硬编码的方式来实现。

但是随着我们数据规模的增大，各种各样跑数据的任务也越来越多，这些任务的要求不仅仅是需要定时执行，还要允许配置任务之间的依赖关系，保证各种任务可以有序执行。这时候仅支持时间依赖的任务调度系统就无法cover住了。因此，我们需要的是一个**工作流调度系统**，它不仅可以支持任务的定时调度，还可以支持任务的依赖执行。

### 2. 市面上一些现有的调度系统  

我们一开始是想寻找一个现有的、成熟的开源调度系统进行简单的二次开发，但是经过简单的调研，发现目前现有的那些调度系统都不能满足我们的需求。

![](http://assets.processon.com/chart_image/5bfeacfae4b04dd279997065.png?_=1543453931801)

因此，我们打算自己开发一套能全面满足需求的工作流调度系统。

## 二、概念&功能介绍   

### 1. Workflow相关   

| 英文名词               | 中文解释         | 详细描述                                                     |
| ---------------------- | ---------------- | ------------------------------------------------------------ |
| workflow               | 任务             | 用来表示一个任务。workflow的执行会依赖两个属性，一个是时间，一个是它的前置workflow，必须两者都满足了才可以开始执行。**workflow的调度时间是必须要配置的，前置依赖可以没有**。 |
| workflowInstance       | 任务实例         | 对于workflow的每一个执行时间点，我们都会产生一个实例。比如一个workflow设置了每小时执行一次，一天就会有24个实例，一个月就会有**24*30**个实例。 |
| workflowInstanceRecord | 任务实例运行记录 | 由于存在重跑的因素，对于每个workflow实例，它都可能有n次运行记录。 |

![](http://assets.processon.com/chart_image/5bfcf397e4b006dc83a5f280.png?_=1543311479436)

#### 1.1 目前支持的调度时间配置  

目前系统支持的调度级别有**分钟、小时、天、周、月、年，自定义crontab，自定义小时，自定义天，自定义周，自定义月**，暂时不支持秒级调度。

| 调度级别          | 描述                                                         | crontab 举例                                                 |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **分钟**          | 从0分钟开始，每n分钟跑一次的任务                             | 从0分钟开始，每5分钟的0秒执行一次：**"0 0/5 \* * * ?"**      |
| **小时**          | 从0点开始，每n小时跑一次的任务                               | 从0点开始，每5个小时的0分0秒执行一次：**"0 0 0/5 \* * ?"**   |
| **天**            | 从1号开始，每n天跑一次的任务                                 | 从1号开始，每3天的0点0分0秒执行一次：**"0 0 0 1/3 \* ?"**    |
| **周**            | 每周周n跑一次的任务                                          | 每周一的0点0分0秒执行一次：**"0 0 0 ? \* 2"**                |
| **月**            | 每月n号跑一次的任务                                          | 每月5号的0点0分0秒执行一次：**"0 0 0 5 \* ?"**               |
| **年**            | 每年xx月xx日才跑一次的任务                                   | 每年6月6号的0点0分0秒执行一次：**"0 0 0 6 6 ?"**             |
| **自定义crontab** | 用户自行填写crontab——**该级别的任务不支持任何上下游依赖**    | 只要符合crontab语法的任何内容                                |
| **自定义小时**    | 可以指定任务在哪些小时执行，比如指定**每天1点、3点、9点、23点执行** | 每天1点、3点、9点、23点的0分0秒执行：**"0 0 1,3,9,23 \* * ?"** |
| **自定义天**      | 可以指定任务在哪几号执行，比如指定**每月1号、5号、11号、22号执行** | 每月1号、5号、11号、22号的0点0分0秒执行：**"0 0 0 1,5,11,22 \* ?"** |
| **自定义周**      | 可以指定任务在一周的哪几天执行，比如指定**每周一、三、六执行** | 每周一、三、六的0点0分0秒执行：**"0 0 0 ? \* 2,4,7"**        |
| **自定义月**      | 可以指定任务在一年的哪几月执行，比如指定**3月、5月、9月**执行 | 3月、5月、9月的1号0点0分0秒执行：**"0 0 0 1 3,5,9 ?"**       |

其实最终这些调度时间配置都会转换为crontab存储到我们的数据库中。**那为什么我们不直接支持用一个crontab来表示所有的调度级别呢**？这个和workflow之间的依赖有关系，我们先了解完workflow之间的依赖再来回答这个问题。

#### 1.2 workflow之间的依赖   

##### 配置 workflow 依赖

在数据相关的任务的里，任务之间的依赖是一个很常见的事情。比如某部门要跑一个日活跃统计任务，但是跑这个任务之前必须保证数据已经落地到磁盘才可以进行，数据落地到磁盘这个事情是ETL相关任务处理的。因此最好的方式就是等ETL任务执行成功了我们才开始执行日活跃统计任务。通过配置**日活跃统计任务**依赖于**ETL任务**，我们就可以保证这两个任务可以有序的执行。

![](http://assets.processon.com/chart_image/5bfcf52be4b0ef094cbee7b2.png?_=1543304737782)

> 为了防止用户无意间配置workflow形成了一个有环的图，当用户配置workflow依赖时，系统会实时检测是否会形成有环图，导致任务执行陷入死循环。如果用户配置的workflow依赖形成了一个环，系统会拒绝该配置。

![](http://assets.processon.com/chart_image/5bf9fc79e4b0852210719712.png?_=1543304933474)

##### workflow实例之间的依赖

workflow之间的依赖会最终映射到workflow实例上面。我们创建每一个实例时，都会根据workflow的依赖配置来设置workflow实例之间的依赖关系。workflow实例在运行前，会先检查它的所有上游实例是否全部执行成功了，只有上游实例都运行成功了才能开始执行。只要上游实例有一个失败，该workflow实例此次运行记录的状态就会直接变成失败。

![](http://assets.processon.com/chart_image/5bfa0c1de4b04dd279938997.png?_=1543114082790)

##### 依赖约束  

在介绍依赖约束之前，我们需要明确两个概念：**调度级别和调度周期**。

- 调度级别：就是上一节介绍的那些，指的调度的**时间粒度**，比如分钟、小时、天。
- 调度周期：指的是具体的一个执行周期，比如分钟级别的调度周期可能是5分钟一次，也可能是10分钟一次，那5分钟或者10分钟就是它的一个调度周期。

对于同周期同级别的调度任务依赖，要创建实例之间的依赖关系是非常简单的。但是，由于调度级别和调度周期存在太多不确定性，如果不对workflow之间的依赖进行一些约束，要创建workflow实例之间的依赖将非常复杂。比如下图这种情况：

![](http://assets.processon.com/chart_image/5bfa1282e4b04dd279938e63.png?_=1543115856917)

workflowG依赖workflowF，G的`01:10:00`实例寻找上游F的实例依赖时，就会有不确定性，有些人可能觉的应该依赖离自己的执行时间最近的那个实例`01:11:00`,但有些人可能觉的应该依赖`00:11:00`这个实例。这就会给我们生成实例依赖关系造成一些麻烦。因此，我们针对各个调度级别制定了具体的依赖约束：

<http://cf.meitu.com/confluence/pages/viewpage.action?pageId=50862112>

**这也是为什么我们不直接通过crontab来配置调度时间的原因**。crontab表达式太过灵活，我们无法从crontab中获取到它对应的调度级别，因此不好对workflow依赖进行相关约束。这也是为什么我们不允许自定义crontab级别的任务配置上下游依赖的原因。

##### workflow自依赖  

有时我们想配置自己的任务实例以串行的方式有序的执行，如果其实有一个实例运行失败了，后面的实例也不能运行。也就是实例的执行要依赖它的上一个实例的执行结果，这就是workflow的自依赖。

![](http://assets.processon.com/chart_image/5bfa0eade4b08c22eea9364c.png?_=1543114712111)

#### 1.3 workflow状态

我们将workflow状态分为四种：**初始化**、**上线**、**下线**、**删除**。

- 初始化：workflow刚创建时的状态，**初始化状态的workflow不会被调度，且不能被其他workflow依赖**。
- 上线：workflow处于运行中，会根据它的调度时间和依赖进行调度。**该状态的workflow不能修改调度时间,也不允许修改依赖**。
- 下线：workflow临时下线，**下线的workflow不会被调度，但可以编辑调度时间，也可以修改依赖。**
- 删除：workflow被删除。

workflow状态变更：

![](http://assets.processon.com/chart_image/5bfa05f7e4b018141e7fad08.png?_=1543112402162)

### 2. Task相关

workflow是任务调度的单位，但并不是真正执行的单位。任务的具体执行细节和task有关，一个workflow会由多个task组成。task没有自己的执行时间，只会随着所属workflow的调度而执行。task之间也可以配置依赖关系，并组织成有向无环图。

![](http://assets.processon.com/chart_image/5bfa28afe4b006dc83a2bf2b.png?_=1543125288319)

**task定义了具体要执行哪些shell语句，以及要在哪些服务器执行。**

| 英文名词     | 中文解释       | 详细描述                                                     |
| ------------ | -------------- | ------------------------------------------------------------ |
| Task         | 节点           | workflow的组成。一个workflow由多个task组成。                 |
| TaskInstance | 节点实例       | 和workflow实例一样，task也会有对应的task实例。每个workflow实例都由若干个task实例组成。只有这些task实例都执行成功了，这个workflow实例才算执行成功。 |
| Agent        | 目标服务器执行脚本的进程 | 每个task实例执行时都会发往对应的服务器执行相应的shell语句。我们会在对应的服务器上安装启动agent进程，之后agent接收到shell语句后会执行shell并返回结果。 |
| TaskRecord        | task实例执行记录 | 由于一个task实例可能在多个agent上执行。task实例的一次运行可以产生多条运行记录，每个agent上的执行情况都会对应到各个TaskRecord上。 |

#### 2.1 workflow和task的区别  

我们已经有了workflow来表示任务的概念，为什么还要定义个task的概念呢？

举一个很简单的例子，经常有一些任务需要共享一些上下文，比如某些变量、时间，如果使用workflow的话，就只能在每个workflow上都设置一遍，增加工作量，修改其实代价也很大。有了task后，我们就可以用task来表达这些任务，同时这些task都在同一个workflow下，就很自然的共用相同的workflow上下文。

同时，通过task，也可以实现类似任务分片的效果，我们可以将一个本来的大任务分解成功一个个task分发到各个agent上执行，提高任务的执行效率，同时还能降低单台服务器的压力。

#### 2.2 workflow实例和task实例的关系

对于每一个workflow实例，我们都会根据当前workflow配置的task信息生成对应的task实例，并将这些task实例和该workflow实例关联起来。

![](http://assets.processon.com/chart_image/5bfa29ece4b04dd279939ccd.png?_=1543125355465)



#### 2.3 task的执行策略

一个task可以配置和多个agent关联，同时我们允许用户配置执行策略来选择在哪些agent上执行。目前我们仅支持两种策略：

- **任意一台**：在关联的agent中，随机选择一台agent执行。(会自动排除掉那些不在线的agent)
- **全部执行**：在所有关联的agent上执行。

后续我们会根据使用方的需求添加更多的执行策略。

#### 2.4 task实例是否执行成功的策略

同样，由于一个task实例可能在多台agent上执行，也就会产生多条记录。这时候就需要一个具体的规则来判断task实例是否执行成功了。我们也允许用户配置具体的判断策略来满足不同的场景。目前我们支持以下两种策略：

- **Single**：只要一台agent执行成功就算这个task实例执行成功。
- **All**：要全部的agent执行成功了才算这个task实例执行成功。

后续我们会根据使用方的需求添加更多的判断策略。

#### 2.5 task的排他执行   

在创建task时，用户可以指定该task是否是排他的。排他执行的解释是：**一个agent上只能有一个task在执行**。因此，排他性质的task在运行前会先检查目标agent上是否有其他task正在执行，同样的，一个普通的task在执行时也要检查目标agent上是否有排他性质的task在执行。

![](http://assets.processon.com/chart_image/5bfa4c43e4b085221071d02a.png?_=1543130409016)

### 3. 整个调度流程介绍  

![](http://assets.processon.com/chart_image/5bfe9c56e4b0ef094cc17421.png?_=1543415321384)

workflowA和workflowB在11月26号都会生成一个实例，到1点10分了，实例A因为时间到了就开始执行，实例B必须等实例A执行成功了才能开始执行。实例A在执行过程中会并发的执行task实例，而实例B的task实例应该存在依赖，会依次的执行task实例。

**task执行的过程就是发送shell到agent执行，我们的调度系统目前也仅支持这种形式的任务执行**。

### 4. 重跑相关

任务执行失败是一个很常见的想象，因此对于一个调度系统而言，任务重跑是一个很核心的功能点。我们调度系统目前支持多种方式的重跑：

- 单个workflow实例的重跑，可以指定是否重跑下游
- 批量重跑workflow实例，可以指定是否重跑下游
- 可以指定重跑某些task实例

#### 4.1 重跑的一些约束  

由于workflow可能存在各种依赖，因此重跑一个workflow就变成一件需要很谨慎的事情。试想一下，如果一个workflow的执行依赖于它上游workflow的结果。那么如果这两个workflow同时进行重跑了，下游的那个workflow的执行就很可能会出现一些问题。

拿上面的那个 **日活跃统计任务依赖ETL任务** 的例子来说。假设日活跃统计任务进入重跑并开始执行了，之后很快有用户也提交了ETL任务的重跑，如果ETL任务的执行过程会先清除旧数据，就会导致日活跃统计任务在运行的过程中获取不到数据的问题，也违反了我们对依赖的定义。

![](http://assets.processon.com/chart_image/5bfd029fe4b0ef094cbf1731.png?_=1543308924053)

为了保证重跑不会出现类似的问题，针对重跑，我们也定义了一些约束：

- 重跑实例本身**不处于待运行或正在运行状态**。
- 重跑实例的所有直接上游**不处于待运行或正在运行状态**。
- 重跑实例的所有直接下游**不处于待运行或正在运行状态**。

### 5. 其他概念&功能   

![](http://assets.processon.com/chart_image/5bfeb19de4b0f012f2368039.png?_=1543418723799)

## 三、接入流程介绍  

![](http://assets.processon.com/chart_image/5bfeaa3de4b034239803f7b7.png?_=1543416584778)

### 1. 接入安装agent

agent目前有两种接入方式可供用户选择：

- 直接执行的安装包agent-exec。用户拿到安装包后，解压即可启动agent进程。agent对任务的处理逻辑是默认的shell实现。
- 在自己的项目中嵌入我们的agent-sdk。用户嵌入我们的agent-sdk后，可以自己定义接收到的任务处理逻辑。这时agent服务就随着用户项目的启动而启动。agent-sdk的接入文档：http://cf.meitu.com/confluence/pages/viewpage.action?pageId=68126173

### 2. 调度java-sdk  

用户可以通过maven引入我们的java-sdk，之后可以直接调用我们的接口进行相关任务管理工作。

sdk相关使用文档：

<http://cf.meitu.com/confluence/pages/viewpage.action?pageId=58132802>

## 四、架构&实现介绍  

### 1. 架构介绍   

![](http://assets.processon.com/chart_image/5ae18ae5e4b090f6eeb406d6.png?_=1543131901501)

#### 1.1 调度服务  

调度服务是分布式调度系统的核心，主要负责**任务实例的生成、实例的调度、任务执行监测以及接收agent的心跳**。调度服务可以部署在多台，他们会自动调整，彼此负责一部分项目组的任务调度(**根据项目组的id来划分**)。

调度服务启动时，会往mysql的相关表中插入一条记录，同时拉取所有在线的调度服务，之后根据指定的算法获取到一个编号，根据这个编号来判断自己要调度哪一些项目组。之后，调度服务进程每10秒就会重新检测一次是否有新的成员加入，如果有新成员加入就要重新分配编号以及更换要调度的项目组。

在调度服务关闭时，会将mysql的相关表中属于自己的那条记录删除，来表示自己已经下线。

另外，在多个调度服务进程中会有一个master的调度服务，只有是master的调度服务进程会执行实例创建、任务监控告警这些任务。master节点目前我们是通过直接写死在配置文件的方式来指定的。

#### 1.2 rpc接口服务  

rpc接口服务主要给使用方提供一些接口。比如创建更新workflow、上线、下线workflow等。使用的是我们部门封装的rpc框架，底层是基于netty。可以部署在多台，实现分布式部署。

#### 1.3 调度sdk

提供给业务方使用的java-sdk。

#### 1.4 agent  

任务执行进程，通常部署到业务方的服务器上用来执行调度发送过去的任务。

#### 1.5 mysql  

mysql主要用于存储workflow、task、agent以及其他的一些信息。

#### 1.6 redis

由于rpc服务以及调度服务分布在各个节点，我们需要用redis来实现分布式锁。同时我们还用了redis的阻塞队列实现消息通知。

### 2. workflow实例的创建   

#### 2.1 实例的预创建

作为master节点的调度服务，会在每天凌晨11点50分生成所有**上线、下线甚至删除**状态的workflow在隔天的所有实例。生成实例的过程中，也会生成实例之间的依赖关系。因此，我们在生成每一个实例的时候，必须保证上游的所有workflow已经生成过实例了（采用递归的方式解决），然后再去创建下游实例，这样才能保证下游实例寻找上游实例依赖时，能找到对应的上游实例。

实例预创建任务流程：

![](http://assets.processon.com/chart_image/5ae1ab69e4b019d3a910059c.png?_=1543156057838)

#### 2.2 **单个实例创建过程**流程图：

![](http://assets.processon.com/chart_image/5af3abd6e4b05f390c69e143.png?_=1543156196820)

#### 2.3 上、下线workflow导致的实例变动  

虽然实例预创建会将workflow隔天的全部实例提前生成，但是由于workflow的上下线，可能导致实例变动，从而需要重新生成实例的情况。

workflow的下线比较简单，只要将当前时间点之后的所有实例的类型设置为下线实例即可。下线实例不会被调度服务调度起来。

workflow的上线情况比较复杂，因为在下线过程中，workflow的调度时间可能发送变化，workflow的依赖关系也可能发生了改变。因此，workflow重新上线的过程中，要处理好实例的变动以及依赖关系的变化。

![](http://assets.processon.com/chart_image/5af3e3a5e4b05f390c6acc4c.png?_=1543157610620)

在上面的上线流程图中，多处地方复用了实例创建部分的代码。**因为在创建单个实例的流程中，会自动根据当前workflow的最新状态修复实例以及实例之间的依赖关系。**

#### 2.3 关于dagGroupId  

对于每一个workflow，我们都会维护一个dagGroupId的属性，用来抽象DAG图。**属于同一个DAG图的所有workflow具有一样的dagGroupId。**

在处理实例之间依赖的过程中，我们需要保证整个DAG中的workflow处于一致的状态。因此在操作某个workflow实例时，就需要对这个workflow所有的DAG中的所有workflow加锁。有了dagGroupId后，我们就可以直接对dagGroupId进行加锁了。

### 3. 任务调度过程   

调度服务的调度是基于workflowInstanceRecord来进行的。系统会拉取所有调度时间已达到、且状态是待执行的workflowInstanceRecord，之后根据一定规则判断该workflowInstanceRecord是否可以运行。具体流程图如下：

![](http://assets.processon.com/chart_image/5bfabb24e4b018141e804c40.png?_=1543160187579)

从上图可以看出，任务的执行是以异步的方式来进行的。**我们分成了两个线程来处理，一个是任务调度线程，一个是taskRecord处理线程，也可以理解为真正执行的线程**。

对于可以执行的任务，会先生成一个待发送状态的taskRecord插入到数据库中，这时候另一个taskRecord处理线程会将这些待发送的record发送出去。

## 五、未来的规划  

- 未来支持更多的task执行策略和成功判断策略
- 对agent资源监控的考虑，通过资源监控，我们可以在执行时选择资源消耗最少的那台agent
- 失败重试时允许设置一段缓冲时间，避免无意义的重试
- 支持任务管理功能，直接通过web界面配置管理任务。
- 支持不同语言版本的agent-sdk及调度sdk
- 调度服务master自动切换
- ...